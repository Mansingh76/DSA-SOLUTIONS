778. Swim in Rising Water

Binary search + BFS/DFS.


class Solution {
    public int swimInWater(int[][] grid) {
        int n = grid.length;
        int left = grid[0][0], right = n * n - 1, ans = right;
        
        while (left <= right) {
            int mid = (left + right) / 2;
            if (canReach(grid, mid)) {
                ans = mid;
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return ans;
    }

    private boolean canReach(int[][] grid, int t) {
        int n = grid.length;
        if (grid[0][0] > t) return false;
        boolean[][] visited = new boolean[n][n];
        return dfs(grid, visited, 0, 0, t);
    }

    private boolean dfs(int[][] grid, boolean[][] visited, int i, int j, int t) {
        int n = grid.length;
        if (i == n-1 && j == n-1) return true;
        visited[i][j] = true;
        int[][] dirs = {{1,0},{-1,0},{0,1},{0,-1}};
        for (int[] d : dirs) {
            int ni = i + d[0], nj = j + d[1];
            if (ni >= 0 && nj >= 0 && ni < n && nj < n && !visited[ni][nj] && grid[ni][nj] <= t) {
                if (dfs(grid, visited, ni, nj, t)) return true;
            }
        }
        return false;
    }
}
